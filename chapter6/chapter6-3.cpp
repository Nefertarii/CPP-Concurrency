// 内存顺序的使用
/*
 * std::memory_order_seq_cst比起其他内存序要简单的多,因为所有操作都将其作为总序
 * 如果不会使用,可以只使用该内存序
 * 只有当基本操作正常工作的时候,才放宽内存序的选择
 */


// 无锁内存的回收
/*
 * 当其他线程对节点进行访问的时候,节点无法被任一线程删除
 * 为避免过多的内存使用,希望这个节点能在删除的时候尽快删除。
 * 本章中介绍了三种技术来保证内存可以被安全的回收：
 * 1. 等待无线程对数据结构进行访问时,删除所有等待删除的对象。
 * 2. 使用风险指针来标识正在被线程访问的对象。
 * 3. 对对象进行引用计数,当没有线程对对象进行引用时将其删除。
 * 所有例子的想法都是使用一种方式去跟踪指定对象上的线程访问数量,当没有现成对对象进行引用时将对象删除
 * 在无锁数据结构中,还有很多方式可以用来回收内存
 * 例如: 理想情况下使用一个垃圾收集器,比起算法来说更容易实现一些
 * 只需要让回收器知道,当节点没被引用的时候回收节点就可以了。
 */


// 防止ABA问题
/*
 * ABA问题指在CAS(Compare-and-Swap)操作时其他线程将变量值A改为了B,但是又被改回了A
 * 等到本线程使用期望值A与当前变量进行比较时,发现变量A没有变,于是CAS就将A值进行了交换操作
 * 但是实际上该值已经被其他线程改变过
 * 在无锁的算法中,这个问题很常见
 * 解决这个问题的一般方法是让变量x中包含一个ABA计数器,“比较/交换”会对加入计数器的x进行操作
 * 每次的值都不一样,计数随之增长
 * 所以x还是原值的前提下,即使有线程对x进行修改,“比较/交换”还是会失败
 */


// 识别忙等待循环和帮助其他线程
/*
 * 最终队列的例子中,已经见识到线程在执行push操作时,必须等待另一个push操作流程的完成
 * 此时等待线程就会被孤立,将会陷入到忙等待循环中
 * 当线程尝试失败的时候会继续循环,这会浪费CPU的计算周期
 * 当之前的线程还没有完成操作前,让等待线程执行未完成的步骤,就能让忙等待的线程不再被阻塞
 */