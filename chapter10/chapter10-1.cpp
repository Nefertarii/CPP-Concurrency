#include "../headfile.h"

//并发相关的错误定位及处理方式

//并发相关的两类错误
/* 不必要的阻塞
 * 一个线程阻塞的时候,不能处理任何任务,因为它在等待其他条件的达成
 * 通常这些条件就是互斥量,条件变量或一个期望值,也可能是一个I/O操作
 * 等待这些条件达成有时会导致不必要的阻塞
 * 像死锁:两个线程互相等待,导致应该完成的任务被搁置,从而导致应用停止响应,
 * 活锁:不同于死锁的阻塞,一些操作在循环中持续检查(如自旋锁),导致CPU被线程的循环占用,表现出来和死锁一样
 * I/O阻塞,外部输入:线程被外部输入阻塞,也会导致应用卡住
 *
 * 恶性的条件竞争
 * 数据竞争:未同步所访问的共享内存,会导致代码产生未定义行为,通常是因为错误的原子操作
 * 破坏常量:通常表现为悬空指针(其他线程将访问的数据删除了),随机存储错误(线程是局部更新的,导致不同线程读取了不同数据)
 * 以及双重释放(两个/多个线程对同一个数据结构进行了一样的删除操作)
 * 程序需要顺序进行的操作被错误的同步破坏也会导致严重的问题
 * 生命周期:线程访问到了不存在的数据(数据被删除或是转移到其他对象中),通常在访问一个局部变量中出现
 * 手动调用join会等待线程完成工作,并且会等待其他为完成的线程
 *
 * 这些会使得应用挂起和反应迟钝,或超长时间完成任务,但是这两种情况中有些比较容易被发现
 * 当一个线程产生死锁或活锁,可以用调试器附着到该线程上进行调试
 * 条件竞争,破坏不变量,以及生命周期问题其表现代码都是可见的(比如,随机崩溃或错误输出)或是可能重写了系统部分的内存使用方式
 *
 * 其中因为执行时间,导致问题无法定位到具体的位置
 * 共享内存系统需要通过线程尝试限制可访问的数据,并且还要正确的使用同步,应用中的任何线程都可以复写(可被其他线程访问的)数据
 */


//定位相关错误
/* 阅读代码
 * 通过阅读代码能找到一些比较明显的问题,在阅读刚写完的代码比已存在时候要容易许多,重点要检查与并发相关的错误
 * 但是审阅多线程代码时,有些错误无法发现,可以尝试可以将代码放置一段时间——先去做应用的另外的部分,在休息之后再集中注意力阅读
 * 同样,当做完其他事情,回头再看这段代码,陌生的感觉会从另一个角度来看你自己以前写的代码
 * 通过自问自答,对每个问题认真考虑,往往也会揭示一些问题
 * 通过重点关注下列问题,能更快的找到代码中的错误
 * 1.并发访问时,哪些数据需要保护
 * 2.如何确定访问数据受到了保护
 * 3.是否会有多个线程同时访问这段代码
 * 4.这个线程获取了哪个互斥量
 * 5.其他线程可能获取哪些互斥量
 * 6.两个线程间的操作是否有依赖关系,如何满足这种关系
 * 7.这个线程加载的数据还是合法数据吗,数据是否被其他线程修改过
 * 8.当假设其他线程可以对数据进行修改,这将意味着什么,怎么确保这样的事情不会发生
 */


/* 测试代码
 * 单线程代码测试起来相对简单,设置各种可能的输入然后执行应用,如果应用行为和输出正确,就能判断其能对给定输入集给出正确的答案
 * 检查错误状态(比如:处理磁盘满载错误)就会比处理可输入测试复杂的多,不过原理是一样的:设置初始条件,然后让程序执行
 * 测试多线程代码的难度就要比单线程大好几个数量级,因为不确定是线程的调度情况
 * 因此,即使使用测试单线程的输入数据,如果有条件变量潜藏在代码中,那么代码的结果可能会时对时错
 * 因为条件变量会在有些时候,因为等待其他事情,而导致结果错误或正确
 * 与并发相关的bug相当难判断,所以在设计并发代码时需要格外谨慎,设计时每段代码都需要进行测试保证没有问题,这样才能在测试出现问题的时候,剔除并发相关的bug
 * 例如,对队列的push和pop,分别进行并发的测试,就要好于直接使用队列测试其中全部功能
 * 测试的目的就是为了消除与并发相关的问题,如果在单线程测试时遇到了问题,那这个问题就是普通的bug,而非并发相关的bug
 * 当问题发生在未测试区域(in the wild),也就是没有在测试范围之内,这样的情况就要特别注意
 * bug出现在应用的多线程部分,并不意味着该问题是一个多线程相关的bug
 * 使用线程池管理某一级并发的时候,通常会有一个可配置的参数,用来指定工作线程的数量
 * 当手动管理线程时,就需要将代码改成单线程的方式进行测试
 * 不管哪种方式,将多线程简化为单线程后,就能将与多线程相关的bug排除掉
 * 反过来说,当问题在单芯系统中消失(即使还是以多线程方式),不过问题在多芯系统或多核系统中出现,就能确定是否被多线程相关的bug,可能是条件变量的问题,还有可能是同步或内存序的问题
 * 测试并发的代码很多,不过通过测试的代码结构就没那么多了
 * 同时对结构的测试和对环境的测试一样重要
 */


//可测试性设计
/* 设计代码时，考虑其的可测试性,可测试的单线程代码设计中许多建议现在依旧适用
 * 通常代码满足一下几点,就很容易进行测试
 * 1.每个函数和类的关系都很清楚
 * 2.函数短小精悍
 * 3.测试用例可以完全控制被测试代码周边的环境
 * 4.执行特定操作的代码应该集中测试,而非分布式测试
 * 5.需要在完成编写后,考虑如何进行测试
 * 并发代码测试的一种最好的方式:去并发化测试
 * 如果代码在线程间的通讯路径上出现问,就可以让一个已通讯的单线程进行执行,这样会减小问题的难度
 * 在对数据进行访问的应用进行测试时,可以使用单线程的方式进行,这样线程通讯和对特定数据块进行访问时只有一个线程,就达到了更容易测试的目的
 * 将代码分割成多个块(比如:读共享数据/变换数据/更新共享数据),就能使用单线程来测试变换数据的部分
 * 麻烦的多线程测试问题,转换成单线程测试读和更新共享数据就会简单许多
 * 在使用某些库时需要小心,因为会用其内部变量存储状态,当多线程使用同一库中的函数,这个状态就会被共享
 * 不过随着对这个库的熟悉,就会清楚这样的情况会在什么时候出现,之后可以适当的加一些保护和同步,让多线程安全并发访问的功能
 * 将并发代码设计的有更好的测试性,要比以代码分块的方式处理并发相关的问题好很多
 * 当然还要注意对非线程安全库的调用,并且还要考虑如何测试已写好的代码,这就会影响设计方向的选择,也会让测试更加容易一些
 */


//多线程测试技术
//蛮力测试
/* 代码有问题的时候,就要求蛮力测试一定能看到这个错误,这就意味着代码要运行很多遍,可能会有很多线程在同一时间运行
 * 要是有bug出现,只能线程出现特殊调度的时候,随着代码运行次数的增加,意味着bug出现的次数会增多
 * 如果测试粒度很细,就像测试之前的线程安全队列,那么蛮力测试会对这段代码持有高度的自信
 * 另一方面,当测试对象体积较大的时候,调度序列将会很长,即使运行了十亿次测试用例,也不会这段代码产生什么信心
 * 蛮力测试的缺点就是可能会误导你,如果写出来的测试用例就为了不让有问题的情况发生,那么不管怎么运行,测试都不会失败(可能会因环境的原因,出现几次失败的情况)
 * 最糟糕的情况就是,问题不会出现在你的测试系统,在某些特殊的系统中,这段代码就会出现问题
 * 在单处理器系统上测试多线程应用,因为每个线程都在同一个处理器上运行,任何事情都是串行的,并且还有很多条件竞争和乒乓缓存
 * 这些问题可能在真正的多处理器系统中,根本不会出现
 * 要避免误导的产生关键点在于成功的蛮力测试,就需要进行仔细考虑和设计,不仅仅是选择相关单元测试,还要遵守测试系统设计准则,以及选定测试环境
 * 保证代码分支被尽可能的测试到,尽可能多的测试线程间的互相作用,还有需要知道哪部分被测试覆盖到,哪些没有覆盖
 */
//组合仿真测试
/* 使用一种特殊的软件,用来模拟代码运行的真实情况
 * 这种软件能让一台物理机上运行多个虚拟环境或系统环境,而硬件环境则由监控软件来完成
 * 除了环境是模拟的以外,模拟软件会记录对数据序列访问,上锁,以及对每个线程的原子操作,然后使用C++内存模型的规则,重复的运行从而识别条件竞争和死锁
 * 虽然这种组合测试可以保证所有与系统相关的问题都会被找到,不过过于零碎的程序将会在这种测试中耗费太长时间
 * 因为组合数目和执行的操作数量将会随线程的增多呈指数增长态势
 * 这个测试最好留给需要细粒度测试的代码段,而非整个应用
 * 另一个缺点就是代码对操作的处理,往往会依赖与模拟软件的可用性
 */
//使用专用库对代码进行测试
/* 可以通过特别实现的库(使用同步原语)来发现一些问题,比如互斥量,锁和条件变量
 * 例如访问某块公共数据的时候,就要将指定的互斥量上锁,
 * 数据被访问后,发现一些互斥量已经上锁,就需要确定相关的互斥量是否被访问线程锁住,如果没有,测试库将报告这个错误
 * 当需要测试库对某块代码进行检查时,可以对相应的共享数据进行标记
 * 多个互斥量同时被一个线程持有时,测试库也会对锁的序列进行记录
 * 如果其他线程以不同的顺序进行上锁,即使在运行的时候测试用例没有发生死锁,测试库都会将这个行为记录为“有潜在死锁”可能
 * 以线程原语实现的库,比如:互斥量和条件变量
 * 当多线程代码在等待,或是被条件变量通过notify_one()提醒的某个线程,测试者可以通过线程,获取到锁
 * 就可以来安排一些特殊的情况,以验证代码是否会在这些特定的环境下产生期望的结果
 * C++标准库实现中,某些测试工具已经存在于标准库中,如果没有实现的测试工具,可以基于标准库进行实现
*/

//构建多线程测试代码
/* 在特定时间内,需要安排一系列线程,同时去执行指定的代码段,两个线程的情况就很容易扩展到多个线程
 * 首先需要知道每个测试的不同之处:
 * 环境布置代码必须首先执行
 * 线程设置代码需要在每个线程上执行
 * 线程上执行的代码需要有并发性
 * 并发执行结束后,后续代码需要对代码的状态进行断言检查
 */

//多线程性能测试
/* 选择以并发的方式开发应用,就是为了能够使用日益增长的处理器数量,通过处理器数量的增加,来提升应用的执行效率
 * 因此确定性能是否有真正的提高就很重要了(就像其他优化一样)
 * 并发效率中有个特别的问题:可扩展性,你希望代码能很快的运行24次,或在24芯的机器上对数据进行24(或更多)次处理,或其他等价情况
 * 当有重要的代码以单线程方式运行时,就会限制性能的提高
 * 因此在做测试之前,回顾一下代码的设计结构是很有必要的,这样就能判断代码在24芯的机器上时,性能会不会提高24倍
 * 或是因为有串行部分的存在,最大的加速比只有3
 * 对数据访问时,处理器之间会有竞争,会对性能有很大的影响
 * 需要合理的权衡性能和处理器的数量:处理器数量太少,就会等待很久,处理器过多,又会因为竞争的原因等待很久
 * 因此在对应的系统上通过不同的配置,检查多线程的性能就很有必要,这样可以得到一张性能图
 * 最起码(如果条件允许)需要在一个单处理器的系统上和一个多处理核芯的系统上进行测试
 */







